var tipuesearch = {"pages":[{"title":" M_math ","text":"M_math M_path Fortran OOP interface for a  POSIX pathname The M_path(3f) module creates an OOP (Object Oriented Programming) interface to other modules in the GPF (General Purpose Fortran) package found at git clone https://github.com/urbanjost/general-purpose-fortran It allows the typical components of a pathname on a POSIX system (Such as GNU/Linux, Unix\n   and Cygwin) to be accessed easily, to render the full pathname of the path and to get basic\n   file properties (permissions, size, ownership, …). The type defined is type path ! COMPONENTS: character ( len = :), allocatable :: name contains ! METHODS: procedure :: branch procedure :: leaf procedure :: stem procedure :: bud procedure :: init procedure :: is_dir procedure :: stat procedure :: readable procedure :: writable procedure :: executable procedure :: exists procedure :: realpath ! OVERLOADED OPERATORS FOR TYPE(path) procedure , private :: eq generic :: operator ( == ) => eq end type path It requires other modules from the package ( Note that you can get and build\n   the GPF package with just a Fortran compiler and make(1) ). This\n   repository is intended for allowing access to the module and its\n   dependencies via the fpm (Fortran Package Manager). Specifically,\n   the Fortran version (not the Haskell version). DOCUMENTATION The man-page DOWNLOAD To create a copy for alteration using fpm use or download the github\n   repository and build it with fpm ( as described at Fortran Package Manager )\n   use git clone https://github.com/urbanjost/M_path.git cd M_path\n     fpm build\n     fpm test fpm run -- . but to use this as intended as a dependency in your fpm.toml project file\n   just add the following into your fpm manifest file: [dependencies] M_path = { git = \"https://github.com/urbanjost/M_path.git\" } Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"path – M_math ","text":"type, public :: path Contents Variables name Constructor path Type-Bound Procedures branch bud executable exists init is_dir leaf readable realpath stat stem writable Source Code path Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Constructor public        interface path private  function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dat Return Value type( path ) Type-Bound Procedures procedure, public :: branch private  function branch(self) result(dirnm) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value character(len=:), allocatable procedure, public :: bud private  function bud(self) result(ext) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value character(len=:), allocatable procedure, public :: executable => path_executable private  function path_executable(self) result(truth) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value logical procedure, public :: exists => path_exists private  function path_exists(self) result(truth) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value logical procedure, public :: init => init_path private  subroutine init_path(self, name) Arguments Type Intent Optional Attributes Name class( path ) :: self character(len=*), intent(in), optional :: name procedure, public :: is_dir => path_isdir private  function path_isdir(self) result(truth) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value logical procedure, public :: leaf private  function leaf(self) result(name) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value character(len=:), allocatable procedure, public :: readable => path_readable private  function path_readable(self) result(truth) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value logical procedure, public :: realpath => path_realpath private  function path_realpath(self) result(fullname) hangs gfortran if the function is called from an I/O statement\nif(fullname.eq.char(0))then\n   call system_perror(‘ path_realpath error for pathname ‘//trim(self%name)//’:’)\nendif Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value character(len=:), allocatable procedure, public :: stat => path_stat private  function path_stat(self) result(buff) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value integer(kind=int64), (14) procedure, public :: stem private  function stem(self) result(basename) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value character(len=:), allocatable procedure, public :: writable => path_writable private  function path_writable(self) result(truth) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: self Return Value logical Source Code type path ! COMPONENTS: character ( len = :), allocatable :: name contains ! METHODS: procedure :: branch procedure :: leaf procedure :: stem ! leaf - prefix procedure :: bud procedure :: init => init_path procedure :: is_dir => path_isdir procedure :: stat => path_stat procedure :: exists => path_exists procedure :: readable => path_readable procedure :: writable => path_writable procedure :: executable => path_executable procedure :: realpath => path_realpath !procedure         :: group !procedure         :: permits !procedure         :: owner !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(path) !   procedure,private :: plus_strings !   generic           :: operator(+) => plus_strings ! !-! procedure         :: construct_from_dat !-! generic           :: assignment(=)  => construct_from_dat !   procedure,private :: minus_seconds !   procedure,private :: minus_path !   generic           :: operator(-)  => minus_seconds !   generic           :: operator(-)  => minus_path !   procedure,private :: eq !   generic           :: operator(==)  => eq end type path","tags":"","loc":"type/path.html"},{"title":"path – M_math","text":"public interface path Contents Module Procedures construct_from_dat Module Procedures private  function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dat Return Value type( path )","tags":"","loc":"interface/path.html"},{"title":"test_branch – M_math","text":"subroutine test_branch() Arguments None Contents Variables file Source Code test_branch Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_branch () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'branch' , msg = '' ) call unit_check ( 'branch' , file % branch (). eq . '/home/user' , file % name , 'branch' , file % branch ()) call unit_check_done ( 'branch' , msg = '' ) end subroutine test_branch","tags":"","loc":"proc/test_branch.html"},{"title":"test_bud – M_math","text":"subroutine test_bud() Arguments None Contents Variables file Source Code test_bud Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_bud () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'bud' , msg = '' ) call unit_check ( 'bud' , file % bud (). eq . '.txt' , file % name , 'bud' , file % bud ()) call unit_check_done ( 'bud' , msg = '' ) end subroutine test_bud","tags":"","loc":"proc/test_bud.html"},{"title":"test_construct_from_dat – M_math","text":"subroutine test_construct_from_dat() Arguments None Contents Variables file Source Code test_construct_from_dat Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_construct_from_dat () type ( path ) :: file file % name = '/home/user/file.txt' call unit_check_start ( 'construct_from_dat' , msg = '' ) call unit_check ( 'construct_from_dat' , file % name . eq . '/home/user/file.txt' , '/home/user/file.txt' , file % name ) call unit_check_done ( 'construct_from_dat' , msg = '' ) end subroutine test_construct_from_dat","tags":"","loc":"proc/test_construct_from_dat.html"},{"title":"test_init_path – M_math","text":"subroutine test_init_path() Arguments None Contents Variables file Source Code test_init_path Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_init_path () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'init_path' , msg = '' ) call unit_check ( 'init_path' , file % name . eq . '/home/user/file.txt' , '/home/user/file.txt' , file % name ) call unit_check_done ( 'init_path' , msg = '' ) end subroutine test_init_path","tags":"","loc":"proc/test_init_path.html"},{"title":"test_leaf – M_math","text":"subroutine test_leaf() Arguments None Contents Variables file Source Code test_leaf Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_leaf () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'leaf' , msg = '' ) call unit_check ( 'leaf' , file % leaf (). eq . 'file.txt' , file % name , 'leaf' , file % leaf ()) call unit_check_done ( 'leaf' , msg = '' ) end subroutine test_leaf","tags":"","loc":"proc/test_leaf.html"},{"title":"test_path_executable – M_math","text":"subroutine test_path_executable() call unit_check(‘path_executable’, 0.eq.0, file%name,file%executable()) Arguments None Contents Variables file Source Code test_path_executable Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_path_executable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'executable.. ',file%executable() call unit_check_start ( 'path_executable' , msg = '' ) !!call unit_check('path_executable', 0.eq.0, file%name,file%executable()) call unit_check_done ( 'path_executable' , msg = '' ) end subroutine test_path_executable","tags":"","loc":"proc/test_path_executable.html"},{"title":"test_path_exists – M_math","text":"subroutine test_path_exists() Arguments None Contents Variables file Source Code test_path_exists Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_path_exists () type ( path ) :: file call file % init ( '.' ) call unit_check_start ( 'path_exists' , msg = '' ) call unit_check ( 'path_exists' , file % exists (), file % name , file % exists ()) file % name = '_notthere_/_notthere_' call unit_check ( 'path_exists' , . not . file % exists (), file % name , file % exists ()) call unit_check_done ( 'path_exists' , msg = '' ) end subroutine test_path_exists","tags":"","loc":"proc/test_path_exists.html"},{"title":"test_path_isdir – M_math","text":"subroutine test_path_isdir() Arguments None Contents Variables dirname file ierr Source Code test_path_isdir Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dirname type( path ), public :: file integer, public :: ierr Source Code subroutine test_path_isdir () type ( path ) :: file character ( len = :), allocatable :: dirname integer :: ierr call unit_check_start ( 'path_isdir' , msg = '' ) call system_getcwd ( dirname , ierr ) call unit_check ( 'path_isdir' , ierr . eq . 0 , 'getting current directory' , dirname ) call file % init ( dirname ) call unit_check ( 'path_isdir' , file % is_dir (), 'current directory' , file % name , 'isdir' , file % is_dir ()) call unit_check_done ( 'path_isdir' , msg = '' ) end subroutine test_path_isdir","tags":"","loc":"proc/test_path_isdir.html"},{"title":"test_path_readable – M_math","text":"subroutine test_path_readable() call unit_check(‘path_readable’, 0.eq.0, file%name,file%readable()) Arguments None Contents Variables file Source Code test_path_readable Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_path_readable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'readable.... ',file%readable() call unit_check_start ( 'path_readable' , msg = '' ) !!call unit_check('path_readable', 0.eq.0, file%name,file%readable()) call unit_check_done ( 'path_readable' , msg = '' ) end subroutine test_path_readable","tags":"","loc":"proc/test_path_readable.html"},{"title":"test_path_realpath – M_math","text":"subroutine test_path_realpath() Arguments None Contents Variables dirname file ierr Source Code test_path_realpath Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dirname type( path ), public :: file integer, public :: ierr Source Code subroutine test_path_realpath () type ( path ) :: file character ( len = :), allocatable :: dirname integer :: ierr call unit_check_start ( 'path_realpath' , msg = '' ) call system_getcwd ( dirname , ierr ) call unit_check ( 'path_isdir' , ierr . eq . 0 , 'getting current directory' , dirname ) call file % init ( '.' ) call unit_check ( 'path_realpath' , file % realpath (). eq . dirname , 'pathname=' , file % name , '=>' , file % realpath (), 'cwd=' , dirname ) call unit_check_done ( 'path_realpath' , msg = '' ) end subroutine test_path_realpath","tags":"","loc":"proc/test_path_realpath.html"},{"title":"test_path_stat – M_math","text":"subroutine test_path_stat() call unit_check(‘path_stat’, 0.eq.0, file%name,100) Arguments None Contents Variables file Source Code test_path_stat Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_path_stat () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'path_stat' , msg = '' ) !!call unit_check('path_stat', 0.eq.0, file%name,100) call unit_check_done ( 'path_stat' , msg = '' ) end subroutine test_path_stat","tags":"","loc":"proc/test_path_stat.html"},{"title":"test_path_writable – M_math","text":"subroutine test_path_writable() call unit_check(‘path_writable’, 0.eq.0, file%name,file%writeable()) Arguments None Contents Variables file Source Code test_path_writable Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_path_writable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'writable.... ',file%writable() call unit_check_start ( 'path_writable' , msg = '' ) !!call unit_check('path_writable', 0.eq.0, file%name,file%writeable()) call unit_check_done ( 'path_writable' , msg = '' ) end subroutine test_path_writable","tags":"","loc":"proc/test_path_writable.html"},{"title":"test_stem – M_math","text":"subroutine test_stem() Arguments None Contents Variables file Source Code test_stem Variables Type Visibility Attributes Name Initial type( path ), public :: file Source Code subroutine test_stem () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'stem' , msg = '' ) call unit_check ( 'stem' , file % stem (). eq . 'file' , file % name , 'stem' , file % stem ()) call unit_check_done ( 'stem' , msg = '' ) end subroutine test_stem","tags":"","loc":"proc/test_stem.html"},{"title":"M_path – M_math","text":"NAME path ( 3 f ) - [ M_path ] OOP interface for a GNU Linux or Unix pathname ( LICENSE : PD ) SYNOPSIS type path ! COMPONENTS : character ( len = : ) , allocatable :: name contains ! METHODS : procedure :: branch procedure :: leaf procedure :: stem procedure :: bud procedure :: init procedure :: is_dir procedure :: stat procedure :: readable procedure :: writable procedure :: executable procedure :: exists procedure :: realpath procedure :: splitup procedure :: joinup ! OVERLOADED OPERATORS FOR TYPE ( path ) procedure , private :: eq generic :: operator ( == ) => eq end type path DESCRIPTION Given a pathname , resolve or expand it into branch / stem . bud and / or branch / leaf , test for file type and access privileges if file exists , and return system statistics . Assumes directory separator is a slash ( ' / ' ) and that filename does not contain trailing spaces . / branch / leaf / branch / stem . bud OPTIONS FILENAME  pathname RETURNS %name name of file %branch () Output FILENAME with its last non - slash component and trailing slashes removed . if FILENAME contains no '/' character , output \".\" ( meaning the current directory ). %leaf () Output FILENAME with anything up to and including the right - most slashes removed . %stem () Output FILENAME leaf with any right - most suffix removed . A suffix is anything from the rightmost period in the filename leaf to the end of the pathname . %bud () Output FILENAME right - most suffix . %is_dir () a logical specifying if path is currently a directory pathname . %exists () determine if file exists %readable () determine if file is readable %writable () determine if file is writable %executable () determine if file is executable %stat () an array of integers describing the current status of the file . returns the same data array as the SYSTEM_STAT ( 3f ) function with the difference that the status of the call is element 14. %realpath () resolve the pathname using the Posix C routine realpath ( 3 c ) EXAMPLE Sample program: program demo_path use M_path , only : path use M_system , only : system_getpwuid , system_getgrgid use M_time , only : fmtdate , u2d use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 character ( len =* ), parameter :: fmt_date = ' year - month - day hour : minute : second ' type ( path ) :: file character ( len =: ), allocatable :: filename integer ( kind = int64 ) :: buff ( 14 ) integer :: i do i = 1 , max ( 1 , command_argument_count ()) if ( command_argument_count (). eq .0 ) then filename = '.' else call getname ( i , filename ) endif file % name = filename ! or call file %init ( filename ) write ( * , * ) ' name ........ ' , file % name write ( * , * ) ' branch ...... ' , file % branch () write ( * , * ) ' leaf ........ ' , file % leaf () write ( * , * ) ' stem ........ ' , file % stem () write ( * , * ) ' bud ......... ' , file % bud () write ( * , * ) ' is_dir ...... ' , file % is_dir () write ( * , * ) ' readable .... ' , file % readable () write ( * , * ) ' writable .... ' , file % writable () write ( * , * ) ' executable .. ' , file % executable () write ( * , * ) ' exists ...... ' , file % exists () write ( * , * ) ' realpath .... ' , file % realpath () write ( * , * ) ' stat ........ ' buff = file % stat () if ( buff ( 14 ) == 0 ) then write ( * , \"(9x,'Device ID(hex/decimal):', T40,Z0,'h/',I0,'d')\" ) & & buff ( 1 ), buff ( 1 ) write ( * , \"(9x,'Inode number:', T40, I0)\" ) & & buff ( 2 ) write ( * , \"(9x,'File mode (octal):', T40, O19)\" ) & & buff ( 3 ) write ( * , \"(9x,'Number of links:', T40, I0)\" ) & & buff ( 4 ) write ( * , \"(9x,'Owner''s uid/username:', T40, I0,1x, A)\" ) & & buff ( 5 ), system_getpwuid ( buff ( 5 )) write ( * , \"(9x,'Owner''s gid/group:', T40, I0,1x, A)\" ) & & buff ( 6 ), system_getgrgid ( buff ( 6 )) write ( * , \"(9x,'Device where located:', T40, I0)\" ) & & buff ( 7 ) write ( * , \"(9x,'File size(bytes):', T40, I0)\" ) & & buff ( 8 ) write ( * , \"(9x,'Last access time:', T40, I0,1x, A)\" ) & & buff ( 9 ), fmtdate ( u2d ( int ( buff ( 9 ))), fmt_date ) write ( * , \"(9x,'Last modification time:', T40, I0,1x, A)\" ) & & buff ( 10 ), fmtdate ( u2d ( int ( buff ( 10 ))), fmt_date ) write ( * , \"(9x,'Last status change time:', T40, I0,1x, A)\" ) & & buff ( 11 ), fmtdate ( u2d ( int ( buff ( 11 ))), fmt_date ) write ( * , \"(9x,'Preferred block size(bytes):', T40, I0)\" ) & & buff ( 12 ) write ( * , \"(9x,'No. of blocks allocated:', T40, I0)\" ) & & buff ( 13 ) else write ( * , * ) ' * path % stat * error : ' , file % name , ' status = ' , status endif write ( * , * ) enddo contains subroutine getname ( i , fn ) integer , intent ( in ) :: i character ( len =: ), allocatable , intent ( out ) :: fn integer :: fn_length ! get pathname from command line arguments call get_command_argument ( i , length = fn_length ) if ( allocated ( filename )) deallocate ( filename ) allocate ( character ( len = fn_length ) :: fn ) call get_command_argument ( i , value = fn ) end subroutine getname end program demo_path Results: Sample program executions: demo_path $HOME $HOME/.bashrc\n\n name........ /home/urbanjs/V600\n branch...... /home/urbanjs\n leaf........ V600\n stem........ V600\n bud.........\n is_dir......  T\n readable....  T\n writable...   T\n executable..  T\n exists......  T\n realpath....  /home/urbanjs/V600\n stat........\n         Device ID(hex/decimal):       3E6BE045h/1047257157d\n         Inode number:                 281474977443215\n         File mode (octal):                          40700\n         Number of links:              1\n         Owner's uid/username:         197609 JSU\n         Owner's gid/group:            197121 None\n         Device where located:         0\n         File size(bytes):             0\n         Last access time:             1559495702 2019-06-02 13:15:02\n         Last modification time:       1559495702 2019-06-02 13:15:02\n         Last status change time:      1559495702 2019-06-02 13:15:02\n         Preferred block size(bytes):  65536\n         No. of blocks allocated:      92\n\n name........ /home/urbanjs/V600/.bashrc\n branch...... /home/urbanjs/V600\n leaf........ .bashrc\n stem........ .bashrc\n bud.........\n is_dir......  F\n readable....  T\n writable...   T\n executable..  T\n exists......  T\n realpath....  /home/urbanjs/V600/.bashrc\n stat........\n         Device ID(hex/decimal):       3E6BE045h/1047257157d\n         Inode number:                 59672695062674129\n         File mode (octal):                         100744\n         Number of links:              1\n         Owner's uid/username:         197609 JSU\n         Owner's gid/group:            4294967295 Unknown+Group\n         Device where located:         0\n         File size(bytes):             8744\n         Last access time:             1434310665 2015-06-14 15:37:45\n         Last modification time:       1533428694 2018-08-04 20:24:54\n         Last status change time:      1533428694 2018-08-04 20:24:54\n         Preferred block size(bytes):  65536\n         No. of blocks allocated:      12 AUTHOR John S. Urban LICENSE Public Domain submodule (M_io) M_path\nend submodule M_path Uses iso_fortran_env M_io M_system M_strings Contents Interfaces path Derived Types path Interfaces public        interface path private  function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dat Return Value type( path ) Derived Types type, public :: path Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name Constructor private\n\n                    \n                    function construct_from_dat (dat) Type-Bound Procedures procedure\n                    ,                  public\n                  :: branch Function procedure\n                    ,                  public\n                  :: bud Function procedure\n                    ,                  public\n                  :: executable =>\n                    path_executable Function procedure\n                    ,                  public\n                  :: exists =>\n                    path_exists Function procedure\n                    ,                  public\n                  :: init =>\n                    init_path Subroutine procedure\n                    ,                  public\n                  :: is_dir =>\n                    path_isdir Function procedure\n                    ,                  public\n                  :: leaf Function procedure\n                    ,                  public\n                  :: readable =>\n                    path_readable Function procedure\n                    ,                  public\n                  :: realpath =>\n                    path_realpath Function procedure\n                    ,                  public\n                  :: stat =>\n                    path_stat Function procedure\n                    ,                  public\n                  :: stem Function procedure\n                    ,                  public\n                  :: writable =>\n                    path_writable Function","tags":"","loc":"module/m_path.html"},{"title":"runtest – M_math","text":"Uses M_framework__msg M_system M_path M_framework__verify setup\nteardown Contents Subroutines test_branch test_bud test_construct_from_dat test_init_path test_leaf test_path_executable test_path_exists test_path_isdir test_path_readable test_path_realpath test_path_stat test_path_writable test_stem Source Code runtest Subroutines subroutine test_branch () Arguments None subroutine test_bud () Arguments None subroutine test_construct_from_dat () Arguments None subroutine test_init_path () Arguments None subroutine test_leaf () Arguments None subroutine test_path_executable () call unit_check(‘path_executable’, 0.eq.0, file%name,file%executable()) Arguments None subroutine test_path_exists () Arguments None subroutine test_path_isdir () Arguments None subroutine test_path_readable () call unit_check(‘path_readable’, 0.eq.0, file%name,file%readable()) Arguments None subroutine test_path_realpath () Arguments None subroutine test_path_stat () call unit_check(‘path_stat’, 0.eq.0, file%name,100) Arguments None subroutine test_path_writable () call unit_check(‘path_writable’, 0.eq.0, file%name,file%writeable()) Arguments None subroutine test_stem () Arguments None Source Code program runtest use M_framework__msg use M_system , only : system_getcwd use M_framework__verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_framework__verify , only : unit_check_level use M_framework__verify , only : unit_check_stop use M_path , only : path implicit none unit_check_level = 0 !! setup if ( unit_check_level . ne . 0 ) then write ( * , * ) 'UNIT_CHECK_LEVEL=' , unit_check_level endif call test_init_path () call test_construct_from_dat () call test_branch () call test_leaf () call test_stem () call test_bud () call test_path_exists () call test_path_isdir () call test_path_readable () call test_path_writable () call test_path_executable () call test_path_realpath () call test_path_stat () call unit_check_stop () !! teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_branch () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'branch' , msg = '' ) call unit_check ( 'branch' , file % branch (). eq . '/home/user' , file % name , 'branch' , file % branch ()) call unit_check_done ( 'branch' , msg = '' ) end subroutine test_branch !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_leaf () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'leaf' , msg = '' ) call unit_check ( 'leaf' , file % leaf (). eq . 'file.txt' , file % name , 'leaf' , file % leaf ()) call unit_check_done ( 'leaf' , msg = '' ) end subroutine test_leaf !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_stem () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'stem' , msg = '' ) call unit_check ( 'stem' , file % stem (). eq . 'file' , file % name , 'stem' , file % stem ()) call unit_check_done ( 'stem' , msg = '' ) end subroutine test_stem !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_bud () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'bud' , msg = '' ) call unit_check ( 'bud' , file % bud (). eq . '.txt' , file % name , 'bud' , file % bud ()) call unit_check_done ( 'bud' , msg = '' ) end subroutine test_bud !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_construct_from_dat () type ( path ) :: file file % name = '/home/user/file.txt' call unit_check_start ( 'construct_from_dat' , msg = '' ) call unit_check ( 'construct_from_dat' , file % name . eq . '/home/user/file.txt' , '/home/user/file.txt' , file % name ) call unit_check_done ( 'construct_from_dat' , msg = '' ) end subroutine test_construct_from_dat !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_init_path () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'init_path' , msg = '' ) call unit_check ( 'init_path' , file % name . eq . '/home/user/file.txt' , '/home/user/file.txt' , file % name ) call unit_check_done ( 'init_path' , msg = '' ) end subroutine test_init_path !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_executable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'executable.. ',file%executable() call unit_check_start ( 'path_executable' , msg = '' ) !!call unit_check('path_executable', 0.eq.0, file%name,file%executable()) call unit_check_done ( 'path_executable' , msg = '' ) end subroutine test_path_executable !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_exists () type ( path ) :: file call file % init ( '.' ) call unit_check_start ( 'path_exists' , msg = '' ) call unit_check ( 'path_exists' , file % exists (), file % name , file % exists ()) file % name = '_notthere_/_notthere_' call unit_check ( 'path_exists' , . not . file % exists (), file % name , file % exists ()) call unit_check_done ( 'path_exists' , msg = '' ) end subroutine test_path_exists !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_isdir () type ( path ) :: file character ( len = :), allocatable :: dirname integer :: ierr call unit_check_start ( 'path_isdir' , msg = '' ) call system_getcwd ( dirname , ierr ) call unit_check ( 'path_isdir' , ierr . eq . 0 , 'getting current directory' , dirname ) call file % init ( dirname ) call unit_check ( 'path_isdir' , file % is_dir (), 'current directory' , file % name , 'isdir' , file % is_dir ()) call unit_check_done ( 'path_isdir' , msg = '' ) end subroutine test_path_isdir !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_readable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'readable.... ',file%readable() call unit_check_start ( 'path_readable' , msg = '' ) !!call unit_check('path_readable', 0.eq.0, file%name,file%readable()) call unit_check_done ( 'path_readable' , msg = '' ) end subroutine test_path_readable !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_realpath () type ( path ) :: file character ( len = :), allocatable :: dirname integer :: ierr call unit_check_start ( 'path_realpath' , msg = '' ) call system_getcwd ( dirname , ierr ) call unit_check ( 'path_isdir' , ierr . eq . 0 , 'getting current directory' , dirname ) call file % init ( '.' ) call unit_check ( 'path_realpath' , file % realpath (). eq . dirname , 'pathname=' , file % name , '=>' , file % realpath (), 'cwd=' , dirname ) call unit_check_done ( 'path_realpath' , msg = '' ) end subroutine test_path_realpath !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_stat () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'path_stat' , msg = '' ) !!call unit_check('path_stat', 0.eq.0, file%name,100) call unit_check_done ( 'path_stat' , msg = '' ) end subroutine test_path_stat !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_writable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'writable.... ',file%writable() call unit_check_start ( 'path_writable' , msg = '' ) !!call unit_check('path_writable', 0.eq.0, file%name,file%writeable()) call unit_check_done ( 'path_writable' , msg = '' ) end subroutine test_path_writable !=================================================================================================================================== end program runtest","tags":"","loc":"program/runtest.html"},{"title":"M_path.f90 – M_math","text":"Contents Modules M_path Source Code M_path.f90 Source Code !> !!##NAME !!    path(3f) - [M_path] OOP interface for a GNU Linux or Unix pathname !!    (LICENSE:PD) !!##SYNOPSIS !! !!    type path !! !!       ! COMPONENTS: !!       character(len=:),allocatable :: name !!    contains !! !!       ! METHODS: !!       procedure    :: branch !!       procedure    :: leaf !!       procedure    :: stem !!       procedure    :: bud !!       procedure    :: init !!       procedure    :: is_dir !!       procedure    :: stat !!       procedure    :: readable !!       procedure    :: writable !!       procedure    :: executable !!       procedure    :: exists !!       procedure    :: realpath !!       procedure    :: splitup !!       procedure    :: joinup !! !!       ! OVERLOADED OPERATORS FOR TYPE(path) !!       procedure,private :: eq !!       generic           :: operator(==)  => eq !!    end type path !! !!##DESCRIPTION !!    Given a pathname, resolve or expand it into branch/stem.bud and/or !!    branch/leaf, test for file type and access privileges if file exists, !!    and return system statistics. !! !!    Assumes directory separator is a slash ('/') and that filename does not !!    contain trailing spaces. !! !!       /branch/leaf !!       /branch/stem.bud !! !!##OPTIONS !!        FILENAME  pathname !! !!##RETURNS !!    %name      name of file !! !!    %branch()  Output FILENAME with its last non-slash component and trailing !!               slashes removed. if FILENAME contains no '/' character, output !!               \".\" (meaning the current directory). !! !!    %leaf()    Output FILENAME with anything up to and including the right-most !!               slashes removed. !!    %stem()    Output FILENAME leaf with any right-most suffix removed. A suffix !!               is anything from the rightmost period in the filename leaf to the !!               end of the pathname. !!    %bud()     Output FILENAME right-most suffix. !! !!    %is_dir()      a logical specifying if path is currently a directory pathname. !!    %exists()      determine if file exists !!    %readable()    determine if file is readable !!    %writable()    determine if file is writable !!    %executable()  determine if file is executable !! !!    %stat()    an array of integers describing the current status of the file. !!               returns the same data array as the SYSTEM_STAT(3f) function with !!               the difference that the status of the call is element 14. !! !!    %realpath()    resolve the pathname using the Posix C routine realpath(3c) !! !!##EXAMPLE !! !!   Sample program: !! !!    program demo_path !!    use M_path, only   : path !!    use M_system, only : system_getpwuid, system_getgrgid !!    use M_time,   only : fmtdate, u2d !!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128 !!    character(len=*),parameter               :: fmt_date='year-month-day hour:minute:second' !!    type(path)                               :: file !!    character(len=:),allocatable             :: filename !!    integer(kind=int64)                      :: buff(14) !!    integer                                  :: i !!       do i = 1 , max(1,command_argument_count()) !!        if(command_argument_count().eq.0)then !!           filename='.' !!        else !!           call getname(i,filename) !!        endif !! !!        file%name=filename !!        ! or !!        call file%init(filename) !! !!        write(*,*)'name........ ',file%name !!        write(*,*)'branch...... ',file%branch() !!        write(*,*)'leaf........ ',file%leaf() !!        write(*,*)'stem........ ',file%stem() !!        write(*,*)'bud......... ',file%bud() !!        write(*,*)'is_dir...... ',file%is_dir() !!        write(*,*)'readable.... ',file%readable() !!        write(*,*)'writable.... ',file%writable() !!        write(*,*)'executable.. ',file%executable() !!        write(*,*)'exists...... ',file%exists() !!        write(*,*)'realpath.... ',file%realpath() !!        write(*,*)'stat........ ' !!        buff=file%stat() !!        if(buff(14) == 0) then !!         write (*,\"(9x,'Device ID(hex/decimal):', T40,Z0,'h/',I0,'d')\")& !!         & buff(1),buff(1) !!         write (*,\"(9x,'Inode number:', T40, I0)\")& !!         & buff(2) !!         write (*,\"(9x,'File mode (octal):', T40, O19)\")& !!         & buff(3) !!         write (*,\"(9x,'Number of links:', T40, I0)\")& !!         & buff(4) !!         write (*,\"(9x,'Owner''s uid/username:', T40, I0,1x, A)\")& !!         & buff(5), system_getpwuid(buff(5)) !!         write (*,\"(9x,'Owner''s gid/group:', T40, I0,1x, A)\")& !!         & buff(6), system_getgrgid(buff(6)) !!         write (*,\"(9x,'Device where located:', T40, I0)\")& !!         & buff(7) !!         write (*,\"(9x,'File size(bytes):', T40, I0)\")& !!         & buff(8) !!         write (*,\"(9x,'Last access time:', T40, I0,1x, A)\")& !!         & buff(9), fmtdate(u2d(int(buff(9))),fmt_date) !!         write (*,\"(9x,'Last modification time:', T40, I0,1x, A)\")& !!         & buff(10),fmtdate(u2d(int(buff(10))),fmt_date) !!         write (*,\"(9x,'Last status change time:', T40, I0,1x, A)\")& !!         & buff(11),fmtdate(u2d(int(buff(11))),fmt_date) !!         write (*,\"(9x,'Preferred block size(bytes):', T40, I0)\")& !!         & buff(12) !!         write (*,\"(9x,'No. of blocks allocated:', T40, I0)\")& !!         & buff(13) !!        else !!         write (*,*) '*path%stat* error: ',file%name,' status= ',status !!        endif !!        write(*,*) !!       enddo !! !!    contains !!    subroutine getname(i,fn) !!    integer,intent(in)                       :: i !!    character(len=:),allocatable,intent(out) :: fn !!    integer                                  :: fn_length !!    ! get pathname from command line arguments !!       call get_command_argument (i , length=fn_length) !!       if(allocated(filename))deallocate(filename) !!       allocate(character(len=fn_length) :: fn) !!       call get_command_argument (i , value=fn) !!    end subroutine getname !!    end program demo_path !!   Results: !! !!   Sample program executions: !! !!     demo_path $HOME $HOME/.bashrc !! !!     name........ /home/urbanjs/V600 !!     branch...... /home/urbanjs !!     leaf........ V600 !!     stem........ V600 !!     bud......... !!     is_dir......  T !!     readable....  T !!     writable...   T !!     executable..  T !!     exists......  T !!     realpath....  /home/urbanjs/V600 !!     stat........ !!             Device ID(hex/decimal):       3E6BE045h/1047257157d !!             Inode number:                 281474977443215 !!             File mode (octal):                          40700 !!             Number of links:              1 !!             Owner's uid/username:         197609 JSU !!             Owner's gid/group:            197121 None !!             Device where located:         0 !!             File size(bytes):             0 !!             Last access time:             1559495702 2019-06-02 13:15:02 !!             Last modification time:       1559495702 2019-06-02 13:15:02 !!             Last status change time:      1559495702 2019-06-02 13:15:02 !!             Preferred block size(bytes):  65536 !!             No. of blocks allocated:      92 !! !!     name........ /home/urbanjs/V600/.bashrc !!     branch...... /home/urbanjs/V600 !!     leaf........ .bashrc !!     stem........ .bashrc !!     bud......... !!     is_dir......  F !!     readable....  T !!     writable...   T !!     executable..  T !!     exists......  T !!     realpath....  /home/urbanjs/V600/.bashrc !!     stat........ !!             Device ID(hex/decimal):       3E6BE045h/1047257157d !!             Inode number:                 59672695062674129 !!             File mode (octal):                         100744 !!             Number of links:              1 !!             Owner's uid/username:         197609 JSU !!             Owner's gid/group:            4294967295 Unknown+Group !!             Device where located:         0 !!             File size(bytes):             8744 !!             Last access time:             1434310665 2015-06-14 15:37:45 !!             Last modification time:       1533428694 2018-08-04 20:24:54 !!             Last status change time:      1533428694 2018-08-04 20:24:54 !!             Preferred block size(bytes):  65536 !!             No. of blocks allocated:      12 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! submodule is not supported by the compiler used to develop this yet or it would be worth a try !!submodule (M_io) M_path !!end submodule M_path ! module M_path ! ! Define an OOP (Object-Oriented Programming) interface for common pathname-related operations ! ! Leveraging the existing procedural functions to do the operations allows ! this to simply be a definition of a derived type ( TYPE(path) ) and the ! methods it supports and overloading of operators to support the new data type. ! use M_io , only : dirname ! strip last component from filename use M_io , only : splitpath ! split a Unix pathname into components use M_io , only : joinpath ! split a Unix pathname into components use M_io , only : separator use M_strings , only : substitute , split Use M_system , only : system_isdir use M_system , only : system_stat , system_realpath , system_perror Use M_system , only : system_access , F_OK , R_OK , W_OK , X_OK use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : dp => real128 implicit none private !----------------------------------------------------------------------------------------------------------------------------------- public path !----------------------------------------------------------------------------------------------------------------------------------- !DERIVED TYPE FILENAME ! type path ! COMPONENTS: character ( len = :), allocatable :: name contains ! METHODS: procedure :: branch procedure :: leaf procedure :: stem ! leaf - prefix procedure :: bud procedure :: init => init_path procedure :: is_dir => path_isdir procedure :: stat => path_stat procedure :: exists => path_exists procedure :: readable => path_readable procedure :: writable => path_writable procedure :: executable => path_executable procedure :: realpath => path_realpath !procedure         :: group !procedure         :: permits !procedure         :: owner !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(path) !   procedure,private :: plus_strings !   generic           :: operator(+) => plus_strings ! !-! procedure         :: construct_from_dat !-! generic           :: assignment(=)  => construct_from_dat !   procedure,private :: minus_seconds !   procedure,private :: minus_path !   generic           :: operator(-)  => minus_seconds !   generic           :: operator(-)  => minus_path !   procedure,private :: eq !   generic           :: operator(==)  => eq end type path !=================================================================================================================================== ! User-defined constructors are created by defining a generic interface ! with the same name as the derived type they're supposed to construct. interface path module procedure construct_from_dat end interface path !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! this function is used internally in the module, but is also declared to be a constructor for creating TYPE(DATE_TYPE) structures ! function construct_from_dat ( dat ) ! ident_1=\"@(#)M_io::construct_from_dat(3f): construct TYPE(path) with DAT date-time array\" character ( len =* ), intent ( in ) :: dat type ( path ) :: construct_from_dat construct_from_dat % name = dat end function construct_from_dat !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! DEFINE THE METHODS FOR THE TYPE ! These functions are privately used to define the methods that TYPE(path) will support !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine init_path ( self , name ) ! ! allow for path object to be initialized. Default is xxxxxxxxxxxxxx ! class ( path ) :: self character ( len =* ), intent ( in ), optional :: name if ( present ( name )) then self % name = name endif end subroutine init_path !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! FUNCTIONS !=================================================================================================================================== function branch ( self ) result ( dirnm ) class ( path ), intent ( in ) :: self !type(path)                :: dirnm character ( len = :), allocatable :: dirnm dirnm = dirname ( self % name ) end function branch !=================================================================================================================================== function splitup ( self ) result ( names ) class ( path ), intent ( in ) :: self character ( len = :), allocatable :: names (:) call split ( self % name , names , '\\/' ) end function splitup !=================================================================================================================================== function joinup ( self , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 ) result ( name ) class ( path ), intent ( in ) :: self character ( len = :), allocatable :: name character ( len =* ), intent ( in ), optional :: a2 character ( len =* ), intent ( in ), optional :: a3 , a4 , a5 , a6 , a7 , a8 , a9 name = joinpath ( self % name , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 ) end function joinup !=================================================================================================================================== function leaf ( self ) result ( name ) class ( path ), intent ( in ) :: self character ( len = :), allocatable :: name integer , parameter :: maxlen = 4096 character ( len = maxlen ) :: split_dir , split_name , split_basename , split_ext call splitpath ( self % name , split_dir , split_name , split_basename , split_ext ) name = trim ( split_name ) end function leaf !=================================================================================================================================== function stem ( self ) result ( basename ) class ( path ), intent ( in ) :: self character ( len = :), allocatable :: basename integer , parameter :: maxlen = 4096 character ( len = maxlen ) :: split_dir , split_name , split_basename , split_ext call splitpath ( self % name , split_dir , split_name , split_basename , split_ext ) basename = trim ( split_basename ) end function stem !=================================================================================================================================== function bud ( self ) result ( ext ) class ( path ), intent ( in ) :: self character ( len = :), allocatable :: ext integer , parameter :: maxlen = 4096 character ( len = maxlen ) :: split_dir , split_name , split_basename , split_ext call splitpath ( self % name , split_dir , split_name , split_basename , split_ext ) ext = trim ( split_ext ) end function bud !=================================================================================================================================== function path_realpath ( self ) result ( fullname ) class ( path ), intent ( in ) :: self character ( len = :), allocatable :: fullname fullname = system_realpath ( self % name ) !!   hangs gfortran if the function is called from an I/O statement !!   if(fullname.eq.char(0))then !!      call system_perror('*path_realpath* error for pathname '//trim(self%name)//':') !!   endif end function path_realpath !=================================================================================================================================== function path_stat ( self ) result ( buff ) class ( path ), intent ( in ) :: self integer ( kind = int64 ) :: buff ( 14 ) integer ( kind = int32 ) :: status call system_stat ( self % name , buff ( 1 : 13 ), status ) buff ( 14 ) = int ( status , kind = int64 ) end function path_stat !=================================================================================================================================== function path_readable ( self ) result ( truth ) logical :: truth class ( path ), intent ( in ) :: self truth = system_access ( self % name , R_OK ) end function path_readable !=================================================================================================================================== function path_writable ( self ) result ( truth ) logical :: truth class ( path ), intent ( in ) :: self truth = system_access ( self % name , W_OK ) end function path_writable !=================================================================================================================================== function path_executable ( self ) result ( truth ) logical :: truth class ( path ), intent ( in ) :: self truth = system_access ( self % name , X_OK ) end function path_executable !=================================================================================================================================== function path_exists ( self ) result ( truth ) logical :: truth class ( path ), intent ( in ) :: self truth = system_access ( self % name , F_OK ) end function path_exists !=================================================================================================================================== function path_isdir ( self ) result ( truth ) class ( path ), intent ( in ) :: self logical :: truth truth = system_isdir ( self % name ) end function path_isdir !=================================================================================================================================== logical function eq ( self , other ) ! ident_2=\"@(#)M_io::eq(3f): compare derived type path objects (eq,lt,gt,le,ge,ne)\" class ( path ), intent ( in ) :: self type ( path ), intent ( in ) :: other eq = . true . !! PLACEHOLDER end function eq !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end module M_path !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/m_path.f90.html"},{"title":"test_suite_M_path.f90 – M_math","text":"Contents Programs runtest Source Code test_suite_M_path.f90 Source Code program runtest use M_framework__msg use M_system , only : system_getcwd use M_framework__verify , only : unit_check_start , unit_check , unit_check_done , unit_check_good , unit_check_bad , unit_check_msg use M_framework__verify , only : unit_check_level use M_framework__verify , only : unit_check_stop use M_path , only : path implicit none unit_check_level = 0 !! setup if ( unit_check_level . ne . 0 ) then write ( * , * ) 'UNIT_CHECK_LEVEL=' , unit_check_level endif call test_init_path () call test_construct_from_dat () call test_branch () call test_leaf () call test_stem () call test_bud () call test_path_exists () call test_path_isdir () call test_path_readable () call test_path_writable () call test_path_executable () call test_path_realpath () call test_path_stat () call unit_check_stop () !! teardown contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_branch () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'branch' , msg = '' ) call unit_check ( 'branch' , file % branch (). eq . '/home/user' , file % name , 'branch' , file % branch ()) call unit_check_done ( 'branch' , msg = '' ) end subroutine test_branch !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_leaf () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'leaf' , msg = '' ) call unit_check ( 'leaf' , file % leaf (). eq . 'file.txt' , file % name , 'leaf' , file % leaf ()) call unit_check_done ( 'leaf' , msg = '' ) end subroutine test_leaf !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_stem () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'stem' , msg = '' ) call unit_check ( 'stem' , file % stem (). eq . 'file' , file % name , 'stem' , file % stem ()) call unit_check_done ( 'stem' , msg = '' ) end subroutine test_stem !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_bud () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'bud' , msg = '' ) call unit_check ( 'bud' , file % bud (). eq . '.txt' , file % name , 'bud' , file % bud ()) call unit_check_done ( 'bud' , msg = '' ) end subroutine test_bud !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_construct_from_dat () type ( path ) :: file file % name = '/home/user/file.txt' call unit_check_start ( 'construct_from_dat' , msg = '' ) call unit_check ( 'construct_from_dat' , file % name . eq . '/home/user/file.txt' , '/home/user/file.txt' , file % name ) call unit_check_done ( 'construct_from_dat' , msg = '' ) end subroutine test_construct_from_dat !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_init_path () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'init_path' , msg = '' ) call unit_check ( 'init_path' , file % name . eq . '/home/user/file.txt' , '/home/user/file.txt' , file % name ) call unit_check_done ( 'init_path' , msg = '' ) end subroutine test_init_path !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_executable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'executable.. ',file%executable() call unit_check_start ( 'path_executable' , msg = '' ) !!call unit_check('path_executable', 0.eq.0, file%name,file%executable()) call unit_check_done ( 'path_executable' , msg = '' ) end subroutine test_path_executable !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_exists () type ( path ) :: file call file % init ( '.' ) call unit_check_start ( 'path_exists' , msg = '' ) call unit_check ( 'path_exists' , file % exists (), file % name , file % exists ()) file % name = '_notthere_/_notthere_' call unit_check ( 'path_exists' , . not . file % exists (), file % name , file % exists ()) call unit_check_done ( 'path_exists' , msg = '' ) end subroutine test_path_exists !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_isdir () type ( path ) :: file character ( len = :), allocatable :: dirname integer :: ierr call unit_check_start ( 'path_isdir' , msg = '' ) call system_getcwd ( dirname , ierr ) call unit_check ( 'path_isdir' , ierr . eq . 0 , 'getting current directory' , dirname ) call file % init ( dirname ) call unit_check ( 'path_isdir' , file % is_dir (), 'current directory' , file % name , 'isdir' , file % is_dir ()) call unit_check_done ( 'path_isdir' , msg = '' ) end subroutine test_path_isdir !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_readable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'readable.... ',file%readable() call unit_check_start ( 'path_readable' , msg = '' ) !!call unit_check('path_readable', 0.eq.0, file%name,file%readable()) call unit_check_done ( 'path_readable' , msg = '' ) end subroutine test_path_readable !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_realpath () type ( path ) :: file character ( len = :), allocatable :: dirname integer :: ierr call unit_check_start ( 'path_realpath' , msg = '' ) call system_getcwd ( dirname , ierr ) call unit_check ( 'path_isdir' , ierr . eq . 0 , 'getting current directory' , dirname ) call file % init ( '.' ) call unit_check ( 'path_realpath' , file % realpath (). eq . dirname , 'pathname=' , file % name , '=>' , file % realpath (), 'cwd=' , dirname ) call unit_check_done ( 'path_realpath' , msg = '' ) end subroutine test_path_realpath !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_stat () type ( path ) :: file call file % init ( '/home/user/file.txt' ) call unit_check_start ( 'path_stat' , msg = '' ) !!call unit_check('path_stat', 0.eq.0, file%name,100) call unit_check_done ( 'path_stat' , msg = '' ) end subroutine test_path_stat !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_path_writable () type ( path ) :: file call file % init ( '/home/user/file.txt' ) !         write(*,*)'writable.... ',file%writable() call unit_check_start ( 'path_writable' , msg = '' ) !!call unit_check('path_writable', 0.eq.0, file%name,file%writeable()) call unit_check_done ( 'path_writable' , msg = '' ) end subroutine test_path_writable !=================================================================================================================================== end program runtest","tags":"","loc":"sourcefile/test_suite_m_path.f90.html"}]}